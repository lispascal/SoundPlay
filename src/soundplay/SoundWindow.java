package soundplay;

import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.KeyEvent;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStream;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetAddress;
import java.net.SocketException;
import java.net.UnknownHostException;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.HashMap;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.PriorityBlockingQueue;
import java.util.concurrent.SynchronousQueue;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.sound.sampled.AudioSystem;
import javax.sound.sampled.Line;
import javax.sound.sampled.LineUnavailableException;
import javax.sound.sampled.Mixer;
import javax.sound.sampled.SourceDataLine;
import javax.sound.sampled.TargetDataLine;
import javax.swing.AbstractAction;
import javax.swing.JFrame;

/**
 *
 * @author Pascal Lis
 */
public class SoundWindow extends javax.swing.JFrame {
    

    /**
     * Creates new form soundWindow
     */
    public SoundWindow() {
        initComponents();
        this.setFocusable(true);
//         getInputMap().put(KeyStroke.getKeyStrokeForEvent(new KeyEvent()));

        //this.addKeyListener(this);
    }
    // private volatile boolean testing = false;
    private boolean testing;
    protected volatile boolean ptt = false;
    private volatile boolean pttEnabled = false;
    private volatile boolean stopSelfSpeaker = false;
    private volatile boolean selfMuted = false;
    private boolean changingKey = false;
    protected int pttKey = KeyEvent.VK_CAPS_LOCK;

    ServerWindow server;
    ClientWindow client;
    
    Thread selfSpeakerThread;
    Chatter chatter;
    Thread chatterThread;
    
    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jScrollPane1 = new javax.swing.JScrollPane();
        MicList = new javax.swing.JList();
        jScrollPane2 = new javax.swing.JScrollPane();
        SpeakerList = new javax.swing.JList();
        jLabel1 = new javax.swing.JLabel();
        jLabel2 = new javax.swing.JLabel();
        TestButton = new javax.swing.JButton();
        pttCheckBox = new javax.swing.JCheckBox();
        muteCheckBox = new javax.swing.JCheckBox();
        PttKeyNameButton = new javax.swing.JButton();
        chatButton = new javax.swing.JButton();
        hostButton = new javax.swing.JButton();
        serverLabel = new javax.swing.JLabel();
        serverInfo = new javax.swing.JTextField();
        lookForLanServers = new javax.swing.JButton();
        jLabel3 = new javax.swing.JLabel();
        usernameLabel = new javax.swing.JLabel();
        usernameField = new javax.swing.JTextField();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        addFocusListener(new java.awt.event.FocusAdapter() {
            public void focusLost(java.awt.event.FocusEvent evt) {
                formFocusLost(evt);
            }
        });
        addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyPressed(java.awt.event.KeyEvent evt) {
                formKeyPressed(evt);
            }
            public void keyReleased(java.awt.event.KeyEvent evt) {
                formKeyReleased(evt);
            }
        });

        MicList.setModel(new javax.swing.AbstractListModel() {
            String[] strings = getMicList();
            public int getSize() { return strings.length; }
            public Object getElementAt(int i) { return strings[i]; }
        });
        MicList.addComponentListener(new java.awt.event.ComponentAdapter() {
            public void componentShown(java.awt.event.ComponentEvent evt) {
                MicListComponentShown(evt);
            }
        });
        jScrollPane1.setViewportView(MicList);

        SpeakerList.setModel(new javax.swing.AbstractListModel() {
            String[] strings = getSpeakerList();
            public int getSize() { return strings.length; }
            public Object getElementAt(int i) { return strings[i]; }
        });
        jScrollPane2.setViewportView(SpeakerList);

        jLabel1.setText("Microphones");

        jLabel2.setText("Speakers");

        TestButton.setText("Test");
        TestButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                TestButtonActionPerformed(evt);
            }
        });

        pttCheckBox.setText("Use Push-to-Talk?");
        pttCheckBox.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                pttCheckBoxActionPerformed(evt);
            }
        });

        muteCheckBox.setText("Mute self");
        muteCheckBox.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                muteCheckBoxActionPerformed(evt);
            }
        });

        PttKeyNameButton.setText(KeyEvent.getKeyText(pttKey));
        PttKeyNameButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                PttKeyNameButtonActionPerformed(evt);
            }
        });

        chatButton.setText("Chat with these Settings");
        chatButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                chatButtonActionPerformed(evt);
            }
        });

        hostButton.setText("Host Server");
        hostButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                hostButtonActionPerformed(evt);
            }
        });

        serverLabel.setText("Server:");

        serverInfo.setText("192.168.1.2:3000");
        serverInfo.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                serverInfoActionPerformed(evt);
            }
        });

        lookForLanServers.setText("Look for Servers on LAN");
        lookForLanServers.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                lookForLanServersActionPerformed(evt);
            }
        });

        jLabel3.setText("PTT button:");

        usernameLabel.setText("Username:");

        usernameField.setText("Name");

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(63, 63, 63)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jLabel1)
                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                        .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 365, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 365, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGroup(javax.swing.GroupLayout.Alignment.LEADING, layout.createSequentialGroup()
                            .addGap(17, 17, 17)
                            .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                .addGroup(layout.createSequentialGroup()
                                    .addComponent(TestButton)
                                    .addGap(18, 18, 18)
                                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                        .addComponent(pttCheckBox)
                                        .addGroup(layout.createSequentialGroup()
                                            .addComponent(muteCheckBox)
                                            .addGap(48, 48, 48)
                                            .addComponent(jLabel3)
                                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                            .addComponent(PttKeyNameButton))))
                                .addGroup(layout.createSequentialGroup()
                                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                        .addComponent(lookForLanServers)
                                        .addGroup(layout.createSequentialGroup()
                                            .addComponent(usernameLabel)
                                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                            .addComponent(usernameField, javax.swing.GroupLayout.PREFERRED_SIZE, 103, javax.swing.GroupLayout.PREFERRED_SIZE)))
                                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                        .addComponent(chatButton)
                                        .addComponent(hostButton, javax.swing.GroupLayout.PREFERRED_SIZE, 163, javax.swing.GroupLayout.PREFERRED_SIZE)))
                                .addGroup(layout.createSequentialGroup()
                                    .addComponent(serverLabel)
                                    .addGap(18, 18, 18)
                                    .addComponent(serverInfo, javax.swing.GroupLayout.PREFERRED_SIZE, 105, javax.swing.GroupLayout.PREFERRED_SIZE)))
                            .addGap(12, 12, 12)))
                    .addComponent(jLabel2))
                .addContainerGap(114, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(21, 21, 21)
                .addComponent(jLabel1)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 92, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(18, 18, 18)
                .addComponent(jLabel2)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 104, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(hostButton)
                    .addComponent(lookForLanServers))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(serverLabel)
                    .addComponent(serverInfo, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(chatButton)
                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                        .addComponent(usernameLabel)
                        .addComponent(usernameField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(TestButton)
                    .addComponent(pttCheckBox))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                        .addComponent(PttKeyNameButton)
                        .addComponent(jLabel3))
                    .addComponent(muteCheckBox))
                .addGap(17, 17, 17))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void TestButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_TestButtonActionPerformed
        if(testing)
        {
            stopSelfSpeaker = true;
            //System.out.println("testing stopped");
        }
        else
        {
            try {
                testMixers();
            } catch (LineUnavailableException | InterruptedException ex) {
                Logger.getLogger(SoundWindow.class.getName()).log(Level.SEVERE, null, ex);
            }
        }
        testing = !testing;
    }//GEN-LAST:event_TestButtonActionPerformed

    private void MicListComponentShown(java.awt.event.ComponentEvent evt) {//GEN-FIRST:event_MicListComponentShown
    }//GEN-LAST:event_MicListComponentShown

    private void formKeyPressed(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_formKeyPressed
        System.out.println(evt.getKeyCode());
        if (changingKey) {
            pttKey = evt.getKeyCode();
            PttKeyNameButton.setText(KeyEvent.getKeyText(pttKey));
            changingKey = false;
            selfMuted = muteCheckBox.isSelected();
        }
        if (evt.getKeyCode() == pttKey) {
            ptt = true;
        }
    }//GEN-LAST:event_formKeyPressed

    private void formFocusLost(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_formFocusLost
        if (pttEnabled || changingKey) {
            requestFocus();
        }

    }//GEN-LAST:event_formFocusLost

    private void formKeyReleased(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_formKeyReleased
        System.out.println(evt.getKeyCode());
        if (evt.getKeyCode() == pttKey) {
            ptt = false;
        }
    }//GEN-LAST:event_formKeyReleased

    private void pttCheckBoxActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_pttCheckBoxActionPerformed
        if (pttCheckBox.isSelected()) {
            pttEnabled = true;
            this.requestFocus();
        } else {
            pttEnabled = false;
        }
    }//GEN-LAST:event_pttCheckBoxActionPerformed

    private void muteCheckBoxActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_muteCheckBoxActionPerformed
        if (muteCheckBox.isSelected()) {
            selfMuted = true;
        } else if (!muteCheckBox.isSelected()) {
            selfMuted = false;
        }
    }//GEN-LAST:event_muteCheckBoxActionPerformed

    private void PttKeyNameButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_PttKeyNameButtonActionPerformed
        selfMuted = true;
        pttCheckBox.setSelected(true);
        pttEnabled = true;
        PttKeyNameButton.setText("   --   ");
        changingKey = true;
        requestFocus();
    }//GEN-LAST:event_PttKeyNameButtonActionPerformed

    private void chatButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_chatButtonActionPerformed
        String sInfo = serverInfo.getText();
        String name = usernameField.getText();

        
        if(client == null)
        {
            try {
                int port = 0;
                InetAddress host;
                
                int splitSpot = sInfo.lastIndexOf(":");
                int serverPort = Integer.decode(sInfo.substring(splitSpot + 1));
                System.out.println(sInfo.substring(0, splitSpot));
                host = InetAddress.getByName(sInfo.substring(0, splitSpot));
                System.out.println("host: " + host + ":" + serverPort);
                //  host = InetAddress.getLocalHost();
                
//                client = new ClientWindow(this, port, host, serverPort);
                client = new ClientWindow(this, name, port, host, serverPort);
                
                client.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
                client.pack();
                client.setVisible(true);
            } catch (UnknownHostException ex) {
                System.out.println("failed to created client window");
                Logger.getLogger(SoundWindow.class.getName()).log(Level.SEVERE, null, ex);
            }
        }
        
    }//GEN-LAST:event_chatButtonActionPerformed

    private void hostButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_hostButtonActionPerformed
        if(server == null)
        {
            server = new ServerWindow(this);
            server.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
            server.pack();
            server.setVisible(true);
        }
        
    }//GEN-LAST:event_hostButtonActionPerformed

    private void serverInfoActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_serverInfoActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_serverInfoActionPerformed

    private void lookForLanServersActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_lookForLanServersActionPerformed
        // TODO add your handling code here:
        ServerList sList = new ServerList(this, true);
        sList.setVisible(true);
    }//GEN-LAST:event_lookForLanServersActionPerformed

    void testMixers() throws LineUnavailableException, InterruptedException {

        int micInt = MicList.getSelectedIndex();
        int speakerInt = SpeakerList.getSelectedIndex();
        boolean oldptt = ptt;
        ptt = false;

        // if it is alive for some reason still, kill the thread.
        if (selfSpeakerThread != null && selfSpeakerThread.isAlive()) {
            stopSelfSpeaker = true;
            selfSpeakerThread.join(10);
        }
        TargetDataLine mic = getMic(micInt);
        SourceDataLine speaker = getSpeaker(speakerInt);
        selfSpeakerThread = new Thread(new SelfSpeaker(mic, speaker));
        selfSpeakerThread.start();
        ptt = oldptt;
    }
    
    void getPubSpkr(OutputStream outputStream, String givenName) throws LineUnavailableException, InterruptedException, IOException {

        int micInt = MicList.getSelectedIndex();
        int speakerInt = SpeakerList.getSelectedIndex();
        
        TargetDataLine mic = getMic(micInt);
        SourceDataLine speaker = getSpeaker(speakerInt);
        chatter = new PublicSpeaker(mic, speaker, outputStream, givenName);
        chatterThread = new Thread((PublicSpeaker)chatter);
        chatterThread.start();
        
    }
//    
//    void playSound(byte[] sound) {
//        if(testing)
//            return;
//        
//        chatter.playSound(sound);
//    }

    TargetDataLine getMic(int micInt) throws LineUnavailableException {
        //System.out.println("mic:" + micInt);
        for (Mixer.Info i : AudioSystem.getMixerInfo()) {
            Mixer ip = AudioSystem.getMixer(i);
            for (Line.Info ipt : ip.getTargetLineInfo()) {
                if (--micInt < 0) {
                    return (TargetDataLine) AudioSystem.getLine(ipt);
                }
            }
        }
        return null;
    }

    SourceDataLine getSpeaker(int speakerInt) throws LineUnavailableException {
        //System.out.println("spk:" + speakerInt);
        for (Mixer.Info i : AudioSystem.getMixerInfo()) {
            Mixer ip = AudioSystem.getMixer(i);
            for (Line.Info ips : ip.getSourceLineInfo()) {
                if (--speakerInt < 0) {
                    return (SourceDataLine) AudioSystem.getLine(ips);
                }
            }
        }
        return null;
    }

    String[] getMicList() {
        ArrayList<String> result = new ArrayList<>();
        for (Mixer.Info i : AudioSystem.getMixerInfo()) {
            Mixer ip = AudioSystem.getMixer(i);
            for (Line.Info ipt : ip.getTargetLineInfo()) {
                result.add(i.getName() + " " + ipt.toString());
            }
        }
        return (String[]) result.toArray(new String[result.size()]);
    }

    String[] getSpeakerList() {
        ArrayList<String> result = new ArrayList<>();
        for (Mixer.Info i : AudioSystem.getMixerInfo()) {
            Mixer ip = AudioSystem.getMixer(i);
            for (Line.Info ips : ip.getSourceLineInfo()) {
                result.add(i.getName() + " " + ips.toString());
            }
        }
        return (String[]) result.toArray(new String[result.size()]);
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(SoundWindow.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(SoundWindow.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(SoundWindow.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(SoundWindow.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new SoundWindow().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JList MicList;
    private javax.swing.JButton PttKeyNameButton;
    private javax.swing.JList SpeakerList;
    private javax.swing.JButton TestButton;
    private javax.swing.JButton chatButton;
    private javax.swing.JButton hostButton;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JButton lookForLanServers;
    private javax.swing.JCheckBox muteCheckBox;
    private javax.swing.JCheckBox pttCheckBox;
    public javax.swing.JTextField serverInfo;
    private javax.swing.JLabel serverLabel;
    private javax.swing.JTextField usernameField;
    private javax.swing.JLabel usernameLabel;
    // End of variables declaration//GEN-END:variables

    void stopPubSpkr() {
        ((PublicSpeaker)chatter).stop = true;
        chatter.close();
        try {
            chatterThread.join();
        } catch (InterruptedException ex) {
            System.out.println("Failed while waiting for publicSpeaker to close");
            Logger.getLogger(SoundWindow.class.getName()).log(Level.SEVERE, null, ex);
        }
    }

/*    private class act extends AbstractAction implements ActionListener {

        @Override
        public void actionPerformed(ActionEvent e) {
            String aCmd = e.getActionCommand();
            if (aCmd.equals("ptton")) {
                ptt = true;
            } else if (aCmd.equals("pttoff"));
            ptt = false;
        }

    }*/

    
    
    
    

    public class Chatter {
        TargetDataLine m;
        SourceDataLine s;

        private Chatter(TargetDataLine mic, SourceDataLine speaker) throws LineUnavailableException {
            m = mic;
            s = speaker;
            m.open(m.getFormat(), 4408*4);
            m.start();
            s.open();
            s.start();
        }
        void playSound(byte[] sound){
            //s.start();
            if(sound != null)
                s.write(sound, 0, sound.length);
            //s.stop();
            }
        /**
         *
         * @return an array with 1000 bytes of microphone data
         */
        byte[] recordSound(){
            return recordSound(false);
        }
        
        byte[] recordSound(boolean tester){
            byte[] b = new byte[1000];
            //System.out.println(m.available());
            // should record if ptt is disabled OR ptt is down, AND
            // self not muted, AND
            // if whether it is the tester is in whether we are testing.
            if ((!pttEnabled || ptt) && !selfMuted && (tester==testing)) {
                if(m.available() > 4410*3)
                {
                    m.flush();
                    b = null;
                }
                else
                    m.read(b, 0, b.length);
            }
            else
            {
                m.flush();
                b = null;
            }
                
            return b;

        }
        
        void close(){
            m.close();
            s.close();
        }
        
    }
    
    
    private class SelfSpeaker extends Chatter implements Runnable {

        public SelfSpeaker(TargetDataLine mic, SourceDataLine speaker) throws LineUnavailableException {
            super(mic, speaker);
        }
        
        /**
         * When "testing" is true this function will record.
         * @return byte array that Chatter.recordSound() does.
         */
        @Override
        byte[] recordSound(){
            return recordSound(true);
        }

        @Override 
        void playSound(byte[] b){
            if(selfMuted || pttEnabled && !ptt)
                s.flush();
            else
                s.write(b, 0, b.length);
        }
        
        @Override
        public void run() {
            
            System.out.println("run");
            while (!stopSelfSpeaker)
            {
                byte[] b = recordSound();
                if(b != null)
                    playSound(b);
            }
            stopSelfSpeaker = false;
            m.close();
            s.close();
            System.out.println("self speaker closed");
        }
        
    }

    public class PublicSpeaker extends Chatter implements Runnable{
        volatile Boolean stop;
        volatile OutputStream out;
        public volatile ObjectOutputStream oos;
        volatile String name;
        public PublicSpeaker(TargetDataLine mic, SourceDataLine speaker, OutputStream outputStream, String givenName) throws LineUnavailableException, IOException {
            super(mic, speaker);
            stop = false;
            name = givenName;
            out = outputStream;
            oos = new ObjectOutputStream(out);
        }
        
        public synchronized void sendObject(Object msg) throws IOException{
            oos.writeObject(msg);
        }
        
        @Override
        public void run(){
            while(!stop)
            {
                try {
                    byte[] b = recordSound();
                    if(b != null)
                    {
                        Message msg = new Message(name, b);
                        
                        if(msg.byteArray.length != 0)
                            sendObject(msg);
                    }
                } catch (IOException ex) {
                    Logger.getLogger(SoundWindow.class.getName()).log(Level.SEVERE, null, ex);
                }
                
            }
            m.close();
            s.close();
        }
        @Override
        void close(){
            super.close();
            try {
                out.close();
            } catch (IOException ex) {
                System.out.println("Failed to close socket outstream");
                Logger.getLogger(SoundWindow.class.getName()).log(Level.SEVERE, null, ex);
            }
           
        }
    }
    
    
    

}
